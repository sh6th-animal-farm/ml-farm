# 워크플로우의 이름입니다. GitHub Actions 탭에서 이 이름으로 표시됩니다.
name: MLFarm Deploy

# 어떤 사건(이벤트)이 발생했을 때 이 작업을 실행할지 정의합니다.
on:
  push:
    # develop 브랜치에 코드가 push(또는 머지)될 때만 자동으로 실행됩니다.
    branches: ["develop"]

# 동일한 브랜치에서 새 푸시가 오면 기존 배포 작업을 취소하고 최신 것만 실행
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

# 실행될 세부 작업들입니다.
jobs:
  deploy:
    # GitHub에서 제공하는 가상 서버(Ubuntu 리눅스)에서 빌드를 수행합니다.
    runs-on: ubuntu-latest

    steps:
      # 1. GitHub 서버로 우리 프로젝트 코드를 내려받습니다.
      - name: Checkout code
        uses: actions/checkout@v3

      # 2. 빌드에 필요한 자바 환경(JDK 11)을 설치합니다.
      - name: Set up JDK 11
        uses: actions/setup-java@v3
        with:
          java-version: "11"
          distribution: "temurin"
          # 빌드 속도를 높이기 위해 Maven 의존성 파일들을 캐싱합니다.
          cache: "maven"

      # 3. 보안상 GitHub에 올리지 않은 설정 파일(.properties)들을 생성합니다.
      # GitHub Settings > Secrets에 저장된 실제 값들을 가져와서 파일로 만듭니다.
      - name: Create Properties Files
        run: |
          # 설정 파일이 들어갈 폴더를 먼저 생성합니다.
          mkdir -p src/main/resources/config
          # 각각의 비밀값을 파일 내용으로 기록합니다.
          echo "${{ secrets.DB_PROPERTIES_CONTENT }}" > src/main/resources/config/db.properties
          echo "${{ secrets.ENTERPRISE_PROPERTIES_CONTENT }}" > src/main/resources/config/enterprise.properties
          echo "${{ secrets.MAIL_PROPERTIES_CONTENT }}" > src/main/resources/config/mail.properties
          echo "${{ secrets.REDIS_PROPERTIES_CONTENT }}" > src/main/resources/config/redis.properties

      # 스프링 프로파일 local을 prod로 변환
      - name: Change Profile to Prod
        run: |
          # application.properties 파일 내의 local을 prod로 문자열 치환
          sed -i 's/spring.profiles.active=local/spring.profiles.active=prod/g' src/main/resources/config/application.properties

          # 확인용 로그 (파일 내용 출력)
          cat src/main/resources/config/application.properties

      # 4. 메이븐(Maven)을 사용하여 프로젝트를 빌드합니다.
      # clean: 이전 빌드 잔여물 삭제 / package: .war 파일 생성 / -DskipTests: 테스트 코드는 생략
      - name: Build with Maven
        run: mvn clean package -DskipTests

      # war 파일 이름 ROOT로 변경
      - name: Rename war file
        run: mv target/mlf-*.war target/ROOT.war

      # 5. 빌드된 .war 파일을 우리 실제 운영 서버로 전송합니다. (SCP 프로토콜 사용)
      - name: Copy WAR to Server
        uses: appleboy/scp-action@master
        with:
          host: ${{ secrets.REMOTE_IP }}
          username: ${{ secrets.REMOTE_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.REMOTE_PORT }}
          # 빌드 결과물인 target 폴더 안의 war 파일만 보냅니다.
          source: "target/*.war"
          # 서버의 톰캣 배포 경로로 전송합니다.
          target: "/opt/apache-tomcat-9.0.113/webapps"
          # 전송 시 'target/' 이라는 폴더 구조는 떼고 파일만 보냅니다.
          strip_components: 1

      # 6. 서버에 접속하여 후처리 작업을 수행합니다. (SSH 접속)
      - name: Restart Tomcat & Path Setup
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.REMOTE_IP }}
          username: ${{ secrets.REMOTE_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.REMOTE_PORT }}
          script: |
            # 기존 ROOT 폴더와 war 파일 삭제 (깔끔한 재배포를 위해)
            sudo rm -rf /opt/apache-tomcat-9.0.113/webapps/ROOT
            # 유저가 업로드할 파일들이 저장될 리눅스 경로를 생성합니다. (-p: 부모 폴더까지 한 번에)
            sudo mkdir -p /mlfarm-data/uploads
            # 톰캣 프로그램이 이 폴더에 파일을 쓰고 읽을 수 있도록 권한(소유자)을 변경합니다.
            sudo chown -R mlfarm:mlfarm /mlfarm-data/uploads
            sudo chown mlfarm:mlfarm /opt/apache-tomcat-9.0.113/webapps/ROOT.war
            # 새로운 .war 파일이 반영되도록 톰캣 서비스를 재시작합니다.
            sudo systemctl restart tomcat
